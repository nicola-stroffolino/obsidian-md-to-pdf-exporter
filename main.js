/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => MyPlugin
});
var import_fs = __toModule(require("fs"));
var import_obsidian = __toModule(require("obsidian"));
var import_path = __toModule(require("path"));
var import_child_process = __toModule(require("child_process"));
var MyPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      const ribbonIconEl = this.addRibbonIcon("dice", "PROVA", (evt) => __async(this, null, function* () {
        const preamble = [
          "\\usepackage{tikz}",
          "\\usetikzlibrary{calc,patterns,positioning,matrix,plotmarks,trees,shapes,decorations}",
          "\\usepackage{color,soul,soulutf8}"
        ];
        const running = this.app;
        const { basePath } = running.vault.adapter;
        const dummy_partialPath = ".obsidian/plugins/obsidian-md-to-pdf-exporter/files/dummy.md";
        const template_partialPath = ".obsidian/plugins/obsidian-md-to-pdf-exporter/templates/eisvogel";
        let activeFile = running.workspace.getActiveFile();
        if (!activeFile)
          return console.log("No file currently open.");
        let text = (yield running.vault.read(activeFile)).split("\n");
        new import_obsidian.Notice(`Exporting to PDF...`);
        const outputFilePath_complete = (0, import_path.join)(basePath, dummy_partialPath);
        yield this.resetFile(outputFilePath_complete);
        yield this.writeFile(outputFilePath_complete, yield this.headerize(preamble));
        let anInteger = 0;
        let i = 0;
        while (text[i].trim().length === 0)
          i++;
        if (text[i].trimStart().trimEnd() == "---")
          text[i] = "";
        else
          text[i] = "---\n\n" + text[i];
        for (let found = false; i < text.length; i++) {
          if (text[i].contains("`")) {
            if (text[i].contains("tikz render")) {
              let tmp = text[i].split(" ").last();
              text[i] = "\\begin{center}\\begin{tikzpicture}";
              if (tmp.startsWith("scale="))
                text[i] += `[${tmp}, transform shape]`;
              found = true;
            } else if (found && text[i].trimStart().trimEnd() == "```") {
              text[i] = "\\end{tikzpicture}\\end{center}";
              found = false;
            }
          } else if (!found) {
            text[i] = text[i].replace("<-->", "$\\longleftrightarrow$");
            text[i] = text[i].replace("<->", "$\\leftrightarrow$");
            text[i] = text[i].replace("--->", "$\\longrightarrow$");
            text[i] = text[i].replace("-->", "$\\longrightarrow$");
            text[i] = text[i].replace("->", "$\\rightarrow$");
            text[i] = text[i].replace("<---", "$\\longleftarrow$");
            text[i] = text[i].replace("<--", "$\\longleftarrow$");
            text[i] = text[i].replace("<-", "$\\leftarrow$");
            let index = text[i].search("=");
            if (index != -1) {
              if (text[i][index] == "\\" || text[i][index + 1] == "\\") {
                console.log(`Trovato un figlio di puttana alla riga ${i} colonna ${index}`);
              }
            }
            text[i] += "\n";
          }
          yield this.writeFile(outputFilePath_complete, text[i] + "\n");
        }
        const contents = (0, import_fs.readFileSync)(outputFilePath_complete, { encoding: "utf8", flag: "r" });
        console.log(contents);
        let command = ["pandoc", `"${outputFilePath_complete}"`, "-f", "markdown", "-t", "pdf", "-o", `"${basePath}/${activeFile.parent.path}${activeFile.basename}.pdf"`, "--template", `"${(0, import_path.join)(basePath, template_partialPath)}"`];
        (0, import_child_process.exec)(command.join(" "), (error, stdout, stderr) => {
          if (error) {
            console.log(`error: ${error.message}`);
            new import_obsidian.Notice(`Error: ${error.message}`);
            return;
          }
          if (stderr) {
            console.log(`stderr: ${stderr}`);
            new import_obsidian.Notice(`stderr: ${stderr}`);
            return;
          }
          console.log(`stdout: ${stdout}`);
          new import_obsidian.Notice("Succesfully exported to PDF.");
        });
      }));
    });
  }
  onunload() {
  }
  localize(str, char, char1, start, end, charNum) {
    let chars = [...str];
    let call = false;
    for (let r = 0, pass = 0, oldpass = 0; r < chars.length - 1; r++) {
      if (chars[r] == "\\" && (chars[r + 1] == char || chars[r + 1] == char1)) {
        if (oldpass != 1)
          pass = 1;
        chars[r] = "";
        r++;
      } else if (charNum == 2) {
        if (chars[r] == char && chars[r + 1] == char || chars[r] == char1 && chars[r + 1] == char1) {
          oldpass = pass;
          if (pass == 1) {
            pass = 0;
          } else {
            call = true;
            chars[r] = start;
            chars[++r] = "";
            r++;
            for (; r < chars.length - 1; r++) {
              if (chars[r] == char && chars[r + 1] == char || chars[r] == char1 && chars[r + 1] == char1) {
                chars[r] = end;
                chars[r + 1] = "";
                break;
              }
            }
          }
        }
      } else if (charNum == 1) {
        if (chars[r] == char) {
          oldpass = pass;
          if (pass == 1) {
            pass = 0;
          } else {
            call = true;
            chars[r] = start;
            r++;
            for (; r < chars.length - 1; r++) {
              if (chars[r] == char) {
                chars[r] = end;
                break;
              }
            }
          }
        }
      }
    }
    let ret = chars.join("");
    if (char === "=" && call) {
      ret = this.localize(this.localize(ret, "*", "_", "\\textbf{", "}", 2), "*", "_", "\\textit{", "}", 1);
    }
    return ret;
  }
  writeFile(outputDir, data) {
    return __async(this, null, function* () {
      try {
        yield import_fs.promises.writeFile(outputDir, data, { flag: "a+" });
        return;
      } catch (err) {
        return console.log(err);
      }
    });
  }
  resetFile(outputDir) {
    return __async(this, null, function* () {
      try {
        yield import_fs.promises.truncate(outputDir, 0);
        return;
      } catch (err) {
        return console.log(err);
      }
    });
  }
  headerize(packageArr) {
    return __async(this, null, function* () {
      let header = "---\nheader-includes:\n";
      for (let i = 0; i < packageArr.length; i++) {
        header += "- " + packageArr[i] + "\n";
      }
      return header;
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgZnN0YXQsIHJlYWRGaWxlU3luYywgd3JpdGVGaWxlU3luYywgcHJvbWlzZXMgYXMgZnNQcm9taXNlcyAgfSBmcm9tICdmcyc7XHJcbmltcG9ydCB7IEFwcCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIE1vZGFsLCBub3JtYWxpemVQYXRoLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgZGlybmFtZSwgam9pbiB9IGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgeyBleGVjIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRcclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRcclxuXHRcdGNvbnN0IHJpYmJvbkljb25FbCA9IHRoaXMuYWRkUmliYm9uSWNvbignZGljZScsICdQUk9WQScsIGFzeW5jIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IHByZWFtYmxlID0gW1xyXG5cdFx0XHRcdFwiXFxcXHVzZXBhY2thZ2V7dGlren1cIixcclxuXHRcdFx0XHRcIlxcXFx1c2V0aWt6bGlicmFyeXtjYWxjLHBhdHRlcm5zLHBvc2l0aW9uaW5nLG1hdHJpeCxwbG90bWFya3MsdHJlZXMsc2hhcGVzLGRlY29yYXRpb25zfVwiLFxyXG5cdFx0XHRcdFwiXFxcXHVzZXBhY2thZ2V7Y29sb3Isc291bCxzb3VsdXRmOH1cIlxyXG5cdFx0XHRdXHJcblxyXG5cdFx0XHRjb25zdCBydW5uaW5nID0gdGhpcy5hcHBcclxuXHJcblx0XHRcdGNvbnN0IHsgYmFzZVBhdGggfSA9IChydW5uaW5nLnZhdWx0LmFkYXB0ZXIgYXMgYW55KTsgLy8gY29uc3QgeyBwZXBwZSB9ID0gY2lhby5hcnJpdmVkZXJjaSAtLS0+IGNvbnN0IHBlcHBlID0gY2lhby5hcnJpdmVkZXJjaS5wZXBwZVxyXG5cclxuXHRcdFx0Y29uc3QgZHVtbXlfcGFydGlhbFBhdGggPSBcIi5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1kLXRvLXBkZi1leHBvcnRlci9maWxlcy9kdW1teS5tZFwiXHJcblx0XHRcdGNvbnN0IHRlbXBsYXRlX3BhcnRpYWxQYXRoID0gXCIub2JzaWRpYW4vcGx1Z2lucy9vYnNpZGlhbi1tZC10by1wZGYtZXhwb3J0ZXIvdGVtcGxhdGVzL2Vpc3ZvZ2VsXCJcclxuXHJcblx0XHRcdFxyXG5cdFx0XHQvKiBSZWFkIEFjdGl2ZSBGaWxlICovXHJcblxyXG5cdFx0XHRsZXQgYWN0aXZlRmlsZSA9IHJ1bm5pbmcud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTsgLy8gdXNlZnVsIHRvIGdldCBzb21lIGZpbGUgaW5mb3JtYXRpb24gd2l0aCBsaWtlIC5wYXRoXHJcblx0XHRcdGlmICghYWN0aXZlRmlsZSkgcmV0dXJuIGNvbnNvbGUubG9nKFwiTm8gZmlsZSBjdXJyZW50bHkgb3Blbi5cIik7XHJcblxyXG5cdFx0XHRsZXQgdGV4dCA9IChhd2FpdCBydW5uaW5nLnZhdWx0LnJlYWQoYWN0aXZlRmlsZSkpLnNwbGl0KCdcXG4nKTtcclxuXHJcblx0XHRcdG5ldyBOb3RpY2UoYEV4cG9ydGluZyB0byBQREYuLi5gKTtcclxuXHJcblx0XHRcdC8qIFdyaXRlIGludG8gRHVtbXkgZmlsZSAqL1xyXG5cdFx0XHRjb25zdCBvdXRwdXRGaWxlUGF0aF9jb21wbGV0ZSA9IGpvaW4oYmFzZVBhdGgsIGR1bW15X3BhcnRpYWxQYXRoKTtcclxuXHRcdFx0XHJcblx0XHRcdGF3YWl0IHRoaXMucmVzZXRGaWxlKG91dHB1dEZpbGVQYXRoX2NvbXBsZXRlKTtcclxuXHRcdFx0YXdhaXQgdGhpcy53cml0ZUZpbGUob3V0cHV0RmlsZVBhdGhfY29tcGxldGUsIGF3YWl0IHRoaXMuaGVhZGVyaXplKHByZWFtYmxlKSk7XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgYW5JbnRlZ2VyID0gMDtcclxuXHRcdFx0bGV0IGkgPSAwO1xyXG5cdFx0XHR3aGlsZSh0ZXh0W2ldLnRyaW0oKS5sZW5ndGggPT09IDApIGkrK1xyXG5cdFx0XHRpZih0ZXh0W2ldLnRyaW1TdGFydCgpLnRyaW1FbmQoKSA9PSAnLS0tJylcclxuXHRcdFx0XHR0ZXh0W2ldID0gJyc7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0ZXh0W2ldID0gJy0tLVxcblxcbicrIHRleHRbaV07XHJcblx0XHRcdGZvciAobGV0IGZvdW5kID0gZmFsc2U7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHRleHRbaV0uY29udGFpbnMoJ2AnKSkge1xyXG5cdFx0XHRcdFx0aWYgKHRleHRbaV0uY29udGFpbnMoJ3Rpa3ogcmVuZGVyJykpIHtcclxuXHRcdFx0XHRcdFx0bGV0IHRtcCA9IHRleHRbaV0uc3BsaXQoJyAnKS5sYXN0KCk7XHJcblx0XHRcdFx0XHRcdHRleHRbaV0gPSAnXFxcXGJlZ2lue2NlbnRlcn1cXFxcYmVnaW57dGlrenBpY3R1cmV9J1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHRtcC5zdGFydHNXaXRoKCdzY2FsZT0nKSkgdGV4dFtpXSArPSBgWyR7dG1wfSwgdHJhbnNmb3JtIHNoYXBlXWBcclxuXHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZVxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChmb3VuZCAmJiB0ZXh0W2ldLnRyaW1TdGFydCgpLnRyaW1FbmQoKSA9PSAnYGBgJykge1xyXG5cdFx0XHRcdFx0XHR0ZXh0W2ldID0gJ1xcXFxlbmR7dGlrenBpY3R1cmV9XFxcXGVuZHtjZW50ZXJ9J1xyXG5cdFx0XHRcdFx0XHRmb3VuZCA9IGZhbHNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmICghZm91bmQpIHtcclxuXHRcdFx0XHRcdHRleHRbaV0gPSB0ZXh0W2ldLnJlcGxhY2UoJzwtLT4nLCckXFxcXGxvbmdsZWZ0cmlnaHRhcnJvdyQnKTtcclxuXHRcdFx0XHRcdHRleHRbaV0gPSB0ZXh0W2ldLnJlcGxhY2UoJzwtPicsJyRcXFxcbGVmdHJpZ2h0YXJyb3ckJyk7XHJcblxyXG5cdFx0XHRcdFx0dGV4dFtpXSA9IHRleHRbaV0ucmVwbGFjZSgnLS0tPicsJyRcXFxcbG9uZ3JpZ2h0YXJyb3ckJyk7XHJcblx0XHRcdFx0XHR0ZXh0W2ldID0gdGV4dFtpXS5yZXBsYWNlKCctLT4nLCckXFxcXGxvbmdyaWdodGFycm93JCcpO1xyXG5cdFx0XHRcdFx0dGV4dFtpXSA9IHRleHRbaV0ucmVwbGFjZSgnLT4nLCckXFxcXHJpZ2h0YXJyb3ckJyk7XHJcblxyXG5cdFx0XHRcdFx0dGV4dFtpXSA9IHRleHRbaV0ucmVwbGFjZSgnPC0tLScsJyRcXFxcbG9uZ2xlZnRhcnJvdyQnKTtcclxuXHRcdFx0XHRcdHRleHRbaV0gPSB0ZXh0W2ldLnJlcGxhY2UoJzwtLScsJyRcXFxcbG9uZ2xlZnRhcnJvdyQnKTtcclxuXHRcdFx0XHRcdHRleHRbaV0gPSB0ZXh0W2ldLnJlcGxhY2UoJzwtJywnJFxcXFxsZWZ0YXJyb3ckJyk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQvLyB0ZXh0W2ldID0gdGhpcy5sb2NhbGl6ZSh0ZXh0W2ldLCc9JywnPScgLCdcXFxcaGx7JywgJ30nLDIpO1xyXG5cdFx0XHRcdFx0Ly8gdGV4dFtpXSA9IHRleHRbaV0ucmVwbGFjZSgnPT0nLCAnXFxcXGhseycpO1xyXG5cdFx0XHRcdFx0Ly8gdGV4dFtpXSA9IHRleHRbaV0ucmVwbGFjZSgnPT0nLCAnfScpO1xyXG5cdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdHdoaWxlIGNvbnRhaW5zKD0pID09IHRydWUgeyBcclxuXHRcdFx0XHRcdFx0Y29udGFpbnMgXFw9PSBvciBjb250YWlucyA9XFw9IFxyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdG1ldHRpIGkgXFxobHsgZSB9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQqL1xyXG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gdGV4dFtpXS5zZWFyY2goXCI9XCIpO1xyXG5cdFx0XHRcdFx0aWYgKGluZGV4ICE9IC0xKSB7XHJcblx0XHRcdFx0XHRcdGlmICh0ZXh0W2ldW2luZGV4XSA9PSAnXFxcXCcgfHwgdGV4dFtpXVtpbmRleCArIDFdID09ICdcXFxcJykge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBUcm92YXRvIHVuIGZpZ2xpbyBkaSBwdXR0YW5hIGFsbGEgcmlnYSAke2l9IGNvbG9ubmEgJHtpbmRleH1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGV4dFtpXSArPSAnXFxuJ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRhd2FpdCB0aGlzLndyaXRlRmlsZShvdXRwdXRGaWxlUGF0aF9jb21wbGV0ZSwgdGV4dFtpXSArICdcXG4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHJcblx0XHRcdC8qIE91dHB1dCBXcml0dGVuIEZpbGUgKi9cclxuXHRcdFx0Y29uc3QgY29udGVudHMgPSByZWFkRmlsZVN5bmMob3V0cHV0RmlsZVBhdGhfY29tcGxldGUsIHtlbmNvZGluZzondXRmOCcsIGZsYWc6J3InfSk7XHJcblx0XHRcdGNvbnNvbGUubG9nKGNvbnRlbnRzKTtcclxuXHRcdFx0XHJcblxyXG5cdFx0XHQvKiBFeGVjdXRlIFBhbmRvYyBDb21tYW5kICovXHJcblx0XHRcdGxldCBjb21tYW5kID0gW1wicGFuZG9jXCIsIGBcIiR7b3V0cHV0RmlsZVBhdGhfY29tcGxldGV9XCJgLCBcIi1mXCIsIFwibWFya2Rvd25cIiwgXCItdFwiLCBcInBkZlwiLCBcIi1vXCIsIGBcIiR7YmFzZVBhdGh9LyR7YWN0aXZlRmlsZS5wYXJlbnQucGF0aH0ke2FjdGl2ZUZpbGUuYmFzZW5hbWV9LnBkZlwiYCwgXCItLXRlbXBsYXRlXCIsIGBcIiR7am9pbihiYXNlUGF0aCwgdGVtcGxhdGVfcGFydGlhbFBhdGgpfVwiYF07XHJcblx0XHRcdFxyXG5cdFx0XHRleGVjKGNvbW1hbmQuam9pbihcIiBcIiksIChlcnJvcjogYW55LCBzdGRvdXQ6IGFueSwgc3RkZXJyOiBhbnkpID0+IHtcclxuXHRcdFx0XHRpZiAoZXJyb3IpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG5cdFx0XHRcdFx0bmV3IE5vdGljZShgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHN0ZGVycikge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYHN0ZGVycjogJHtzdGRlcnJ9YCk7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBzdGRlcnI6ICR7c3RkZXJyfWApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zb2xlLmxvZyhgc3Rkb3V0OiAke3N0ZG91dH1gKTtcclxuXHRcdFx0XHRuZXcgTm90aWNlKCdTdWNjZXNmdWxseSBleHBvcnRlZCB0byBQREYuJyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRvbnVubG9hZCgpIHtcclxuXHJcblx0fVxyXG5cclxuXHRsb2NhbGl6ZShzdHIgOnN0cmluZywgY2hhciA6IHN0cmluZywgY2hhcjEgOnN0cmluZywgc3RhcnQgOnN0cmluZywgZW5kIDogc3RyaW5nLCBjaGFyTnVtIDogbnVtYmVyKSA6c3RyaW5ne1xyXG5cdFx0bGV0IGNoYXJzID0gWy4uLnN0cl07XHJcblx0XHRsZXQgY2FsbCA9IGZhbHNlO1xyXG5cclxuXHRcdGZvcihsZXQgciA9IDAsIHBhc3MgPSAwLCBvbGRwYXNzID0gMDsgciA8IGNoYXJzLmxlbmd0aCAtMTsgcisrKXtcclxuXHRcdFx0aWYoKGNoYXJzW3JdID09ICdcXFxcJyAmJiAoY2hhcnNbcisxXSA9PSBjaGFyIHx8IGNoYXJzW3IrMV0gPT0gY2hhcjEgKSkpe1xyXG5cdFx0XHRcdGlmKG9sZHBhc3MgIT0gMSlcclxuXHRcdFx0XHRcdHBhc3MgPSAxO1xyXG5cdFx0XHRcdGNoYXJzW3JdID0gJyc7XHJcblx0XHRcdFx0Ly8gYWxlcnQoY2hhcnMpO1xyXG5cdFx0XHRcdHIrKztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChjaGFyTnVtID09IDIpe1xyXG5cdFx0XHRcdGlmKChjaGFyc1tyXSA9PSBjaGFyICYmIGNoYXJzW3IrMV0gPT0gY2hhcikgfHwgKGNoYXJzW3JdID09IGNoYXIxICYmIGNoYXJzW3IrMV0gPT0gY2hhcjEpKXtcclxuXHRcdFx0XHRcdG9sZHBhc3MgPSBwYXNzO1xyXG5cclxuXHRcdFx0XHRcdGlmIChwYXNzID09IDEpe1xyXG5cdFx0XHRcdFx0XHRwYXNzID0gMDtcclxuXHRcdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0XHRjYWxsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0Y2hhcnNbcl0gPSBzdGFydDtcclxuXHRcdFx0XHRcdFx0Y2hhcnNbKytyXSA9ICcnO1xyXG5cdFx0XHRcdFx0XHRyKys7XHJcblx0XHRcdFx0XHRcdGZvcig7IHIgPCBjaGFycy5sZW5ndGggLTE7IHIrKyl7XHJcblx0XHRcdFx0XHRcdFx0aWYoKGNoYXJzW3JdID09IGNoYXIgJiYgY2hhcnNbcisxXSA9PSBjaGFyKSB8fCAoY2hhcnNbcl0gPT0gY2hhcjEgJiYgY2hhcnNbcisxXSA9PSBjaGFyMSkpe1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2hhcnNbcl0gPSBlbmQ7XHJcblx0XHRcdFx0XHRcdFx0XHRjaGFyc1tyKzFdID0gJyc7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKGNoYXJOdW0gPT0gMSl7XHJcblx0XHRcdFx0aWYoY2hhcnNbcl0gPT0gY2hhcil7XHJcblx0XHRcdFx0XHRvbGRwYXNzID0gcGFzcztcclxuXHJcblx0XHRcdFx0XHRpZiAocGFzcyA9PSAxKXtcclxuXHRcdFx0XHRcdFx0cGFzcyA9IDA7XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0Y2FsbCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGNoYXJzW3JdID0gc3RhcnQ7XHJcblx0XHRcdFx0XHRcdC8vIGNoYXJzWysrcl0gPSAnICc7XHJcblx0XHRcdFx0XHRcdHIrKztcclxuXHRcdFx0XHRcdFx0Zm9yKDsgciA8IGNoYXJzLmxlbmd0aCAtMTsgcisrKXtcclxuXHRcdFx0XHRcdFx0XHRpZihjaGFyc1tyXSA9PSBjaGFyKXtcclxuXHRcdFx0XHRcdFx0XHRcdGNoYXJzW3JdID0gZW5kO1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gY2hhcnNbcisxXSA9ICcgJztcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRsZXQgcmV0ID0gY2hhcnMuam9pbignJyk7XHJcblxyXG5cdFx0aWYoY2hhciA9PT0gJz0nICYmIGNhbGwpe1xyXG5cdFx0XHRyZXQgPSB0aGlzLmxvY2FsaXplKHRoaXMubG9jYWxpemUocmV0LCAnKicsJ18nLCAnXFxcXHRleHRiZnsnLCd9JywyKSwgJyonLCdfJywgJ1xcXFx0ZXh0aXR7JywnfScsMSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiByZXRcclxuXHR9XHJcblx0XHJcblx0YXN5bmMgd3JpdGVGaWxlKG91dHB1dERpcjogc3RyaW5nLCBkYXRhOiBhbnkpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGF3YWl0IGZzUHJvbWlzZXMud3JpdGVGaWxlKG91dHB1dERpciwgZGF0YSwge2ZsYWc6ICdhKyd9KTtcclxuXHRcdCAgXHRcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7IHJldHVybiBjb25zb2xlLmxvZyhlcnIpIH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIHJlc2V0RmlsZShvdXRwdXREaXI6IHN0cmluZykge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0YXdhaXQgZnNQcm9taXNlcy50cnVuY2F0ZShvdXRwdXREaXIsIDApO1xyXG5cdFx0ICBcdFxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9IGNhdGNoIChlcnIpIHsgcmV0dXJuIGNvbnNvbGUubG9nKGVycikgfVxyXG5cdH1cclxuXHJcblx0YXN5bmMgaGVhZGVyaXplKHBhY2thZ2VBcnI6IHN0cmluZ1tdKSB7XHJcblx0XHRsZXQgaGVhZGVyID0gXCItLS1cXG5oZWFkZXItaW5jbHVkZXM6XFxuXCJcclxuXHJcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgcGFja2FnZUFyci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRoZWFkZXIgKz0gXCItIFwiICsgcGFja2FnZUFycltpXSArIFwiXFxuXCJcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaGVhZGVyXHJcblx0fVxyXG59XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQTRFO0FBQzVFLHNCQUEyRztBQUMzRyxrQkFBOEI7QUFDOUIsMkJBQXFCO0FBRXJCLDZCQUFzQyx1QkFBTztBQUFBLEVBRXRDLFNBQVM7QUFBQTtBQUVkLFlBQU0sZUFBZSxLQUFLLGNBQWMsUUFBUSxTQUFTLENBQU8sUUFBb0I7QUFFbkYsY0FBTSxXQUFXO0FBQUEsVUFDaEI7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBO0FBR0QsY0FBTSxVQUFVLEtBQUs7QUFFckIsY0FBTSxFQUFFLGFBQWMsUUFBUSxNQUFNO0FBRXBDLGNBQU0s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
